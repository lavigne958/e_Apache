\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}

\title{Rapport projet Un server HTTP}
\author{Lavigne Alexandre - Vallade Vincent}
\date{04/01/2017}


\begin{document}

\maketitle

\section*{Introduction}

Ce rapport décrit notre raisonnement et les solutions apportées pour répondre aux exercices donnés
par le projet de construction d'un mini-serveur HTTP pour l'UE Programation Répartie.\hbox{}

Ce serveur suit le protocole HTTP 1.1. par ailleurs, il n'accepte que la requette de type GET (dont le détail sera décrit par la suite)\hbox{}

Le projet est élaboré en langage C et la constante: XOPEN\_SOURCE est définit avec la valeur: 700



\section{Structure du Server}

Le serveur HTTP prend en argument à son lancement:
\begin{itemize}
\item un port d'écoute
\item le nombre de clients que l'on peut accepter à la fois
\item un nombre d'octets qu'un client peut demander au maximum par minute
\end{itemize}

Pour cette première partie nous avons essayé de concevoir un serveur HTTP en anticipant les questions 2 et 3.\hbox{}

Nous avons conçu la partie principale du serveur pour que sa seule tâche soit de recevoir les requêtes des clients sur le socket d'écoute et de lancer un thread tout de suite après.\hbox{}

Le serveur établit donc toute l'initialisation puis lance une boucle infinie durant laquelle il écoute pour une connection de type TCP sur le port donné.
\hbox{}

Le serveur redéfinit le *handler* pour le signal SIGINT afin de fermer le socket, détruire le sémaphore, et toutes autres ressources allouées, ce qui nous permet de fermer le serveur proprement via un CTRL+C.
Pour faciliter le transfert d'informations entre le serveur principal et le thread qui traite avec un client, nous avons créer une structure ``client'' contenant les informations suivantes:
\begin{itemize}
\item le socket de communication avec le client
\item le descripteur de fichier de journalisation
\item la structure sockaddr\_in du client
\item le semaphore pour gérer l'accès en concurrence du fichier de journalisation
\end{itemize}

La suite du document décrit le code du thread contenut dans le fichier ``requete.c''

Le thread lit les caractères un par un sur le socket de communication jusqu'a trouver un caractère '\textbackslash{}n'.
Ensuite il extrait le premier mot pour vérifier qu'il corespond bien à 'GET'.
Il extrait le deuxième mot pour vérifier le chemin que le client demande.

Sous unix pour demander une ressource à partir du dossier courant il suffit que le nom de cette ressource ne commence pas par '/', nous vérifions alors sa présence et le
supprimons du chemin s'il existe. Nous vérifions si la ressource existe et si le server à les droits en lecture dessus.\hbox{}

Ensuite le thread vérifie le type mime du fichier grâce à une fonction permetant de parser le fichier '/etc/mime.types' et de trouver si un mime-type existe, si oui alors
il l'envoie au serveur sinon le serveur envoie 'text/plain', de cette manière nous protégeons le client contre toute exécution de code alors que le type du fichier est indéterminé.\hbox{}

La commande pour rechercher un type mime est la suivante: \hbox{}
\begin{lstlisting}
  grep -w %s /etc/mime.types |
  awk '{if ($2 != \"\") if ($2 ~ /%s/) print $1}'
\end{lstlisting}

Cette ligne de commande BASH imprime les lignes du fichier /etc/mim.types qui contiennent le mot placé '\%s' puis awk fils les lignes dont la 2ème colonne est vide, puis si la deuxième colonne match l'expression régulière /extention/ où extention est l'extention cherchée alors on imprime sur la sortie standard la première colonne, qui correspond au type mime recherché.\hbox{}

Une fois toutes les vérifications effectuées le thread envoie sa réponse au serveur, donc les headers contenant le code de retour, puis le type mime du fichier.
Ensuite une fonction dédiée ouvre, lit et envoie le fichier au client.
\hbox{}
Une vérification des erreurs est éffectuée durant l'exécution et renvoie s'il le faut un code de retour 404 ou 403 ou 500 (voir questions suivantes)

\section{Journalisation}

Après l'envoie d'une réponse à un client un appel à la méthode write\_log est effectuée.
On écrit dans une chaine de caractères à l'aide de sprintf toutes les informations que l'on veut sauvegarder dans le log. La date de fin de traitement de la requête est récupérée grâce à un appel
à la méthode get\_time(char *result) qui récupère la date grâce à la fonction localtime et la transmet dans la chaîne passée en argument.\hbox{}
Nous utilisons un sémaphore pour gérer l'accès en concurrence au fichier de journalisation. Ce fichier est ouvert qu'une seule fois au lancement du serveur et le descripteur de ce fichier est transmis
aux threads par la structure ``client''.

\section{Fichier exécutable}

Dans la méthode ``process\_request'', nous vérifions le type du fichier demandé par le serveur grace à la méthode ``check\_file'', si ce fichier est accessible en lecture et executable: alors nous créons un processus fils via la méthode fork() et appelons la methode ``execl'' qui permet d'écraser le code de ce fils avec celui de l'exécutable. \hbox{}

Avant de lancer la methode ``execl'' nous prenons soin de rediriger la sortie standards du fils vers un fichier temporaire. Cette solution nous permet de suivre l'exécution du fils, si celui ci ce termine normalement alors nous n'avons qu'a lire et envoyer le fichier temporaire sur le socket, ainsi nous connaissons la taille du résultat à envoyer.

En cas d'erreur ou si le fils ne s'est pas terminé au bout de 10 secondes, nous renvoyons au serveur le code ``500 Internal Error''.

\section{Requêtes persistentes}

Le thread créé par le serveur principal pour gérer les connections avec le client va se contenter de lire tous les headers, puis va creer un sous thread pour chaque requêtes du client.
Une structure ``thread\_fils'' a été créée pour transmettre des informations à ce sous thread.
\begin{itemize}
\item counter: l'adresse d'un compteur qui indique le nombre de sous thread terminé
\item id: l'id du thread, sa valeur est sa position de création.
\item mutex: un mutex pour l'accès au socket du client
\item cond: condition sur laquelle les threads s'endorment si ils ne peuvent pas accéder
  au socket client.
\item cli: un pointeur vers une structure client
\item get: une chaine de caractères contenant la première ligne lue par le thread de gestion de connection, cette ligne est sensée être la ligne du GET.
\end{itemize}

Le sous thread va verifier que la chaine get transmise commence bien par le mot clé ``GET'' et que le chemin est valide. Puis pour la gestion de la concurrence entre les threads, il va verifier que l'id qu'on lui a transmis est égal au compteur passé dans la structure. Si c'est le cas le thread s'exécute, sinon il s'endort.

à la fin de son exécution le thread réveille tout les autres thread en attente sur la condition, ce qui nous évite les problème de famine.


\end{document}


